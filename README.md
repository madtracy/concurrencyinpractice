concurrency
===========

Java Concurrency in Practice 笔记


# 概述

# 造成多线程不安全的原因
 * 对象的状态可变
 * 对象可以被多个线程访问和修改
 
# 解决多线程不安全的方法
 * 针对对象可变的策略
  - 1.无状态对象一定线程安全(因为无状态,因此不存在可变性的问题)
  - 2.无状态的类中添加一个完全由线程安全的对象管理的状态时，那么这个类仍然是线程安全的(策略1的弱化)
  - 3.不可变对象:不可变对象一定是线程安全的(发布后状态不会改变,初始化安全由Java内存模型提供保证)
  - 4.事实不可变对象:可以理解为3的弱化
 * 针对多线程访问的策略
  - 1.线程封闭：仅在单线程内访问数据

 * 针对既可变又会被多线程访问和修改的可变对象
  - 1.线程安全共享：线程安全的对象在内部实现同步，多线程通过对象的公有接口来进行访问，而不需要额外的同步
  - 2.保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

# 发布与逸出的问题
 * 不正确的发布：一个尚未被完全创建的对象被发布出去，不正确的发布会造成线程安全性问题。
 * 不正确的构造：如果this引用在构造过程中逸出。
 * 安全的发布：在发布该对象的的线程时都必须使用同步。  
  - 要安全的发布一个对象，对象的引用和对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：
  - 1.在静态初始化函数中初始化一个对象的引用(由JVM内部存在的同步机制保证)
  - 2.将对象的引用保存到volatile类型的域或者AtomicReference对象中
  - 3.将对象的引用保存到某个正确构造对象的final类型域中
  - 4.将对象的引用保存到一个由锁保护的域中。
  
 * 对象的发布取决于它的可变性：
  - 1.不可变对象(定义保证了正确的构造,this引用在构造过程中不会逸出)可以通过任意机制来发布。
  - 2.事实不可变对象不许通过安全方式来发布。
  - 3.可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

