# 对象的共享

# 可见性
  一个线程修改了对象状态后，其他线程能够看到发生的状态变化。
  
# volatile 变量
  1.读取volatile类型的变量时总会返回最新写入的值
  
  2.对于double和long(64位)类型的变量，JVM允许将64位的读操作或者写操作分解为两个32位的操作，因此，即使不考虑可见性的问题，对于共享且可变的double和long类型的变量也是不安全的。除非使用volatile来声明它们，或者用锁保护起来。
  
  3.volatile不足以保证递增操作(count++)的原子性:递增操作包括"读取-修改-写入",在写入钱，原来的值可能已经发生了变化。除非你能保证只有一个线程对变量进行写操作。(原子变量提供了递增的原子操作)
  
  4.volatile只能保证可见性,不保证原子性,参见第三条。(加锁既可以保证可见性又可以保证原子性)
  
  volatile的一种典型用法：检查某个状态标记以判断是否退出循环
```java
  volatile boolean asleep;
  ...
    while(!asleep)
      countSomeSheep();
```

  当且仅当满足以下所有条件时，才应该使用volatile：
  
  1)对变量的写入不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
    
  2)该变量不会与其他状态变量一起纳入不变性条件中。(应该是不鼓励使用,参见SO上[这个帖子](http://stackoverflow.com/questions/9868577/how-to-comprehend-thevariabledoes-notparticipatein-invariantswith-otherst))
    
  3)在访问变量时不需要加锁。  

# 发布与逸出
  1.发布的意思是指，使对象能够在当前的作用域之外的代码中使用
  
  发布对象的方法：
  
  1)将对象的引用保存到一个公有的静态变量中(对象的非私有域中引用的所有对象同样被发布)，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到其他对象，那么这些对象也都会被发布。
  
  2)当把一个对象传递给某个外部方法时，就相当于发布了这个对象。(假如有一个类C，对于C来说，外部方法是指行为并不完全由C来规定的方法，包括其他类中定义的方法以及类C中可以被改写的方法。)
  
  3)最后一种发布对象的或其内部状态的机制就是发布一个内部的类实例。(内部类实例包含了对外部类实例的隐含引用)
  
  2.逸出
  
  当某个不应该发布的对象被发布时，这种情况就被称为"逸出"。
    
  不要在构造过程中使this引用逸出。因为当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。
    
  在构造过程中使this逸出的一个常见错误是：在构造函数中启动一个线程。无论是显示的还是隐式的，this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。可以在构造函数中创建线程，但最好不要立即启动它。
    
  在构造函数中调用一个可改写的实例方法(非private与final)时，同样会导致this引用在构造过程中逸出。
    
  如果想在构造函数中注册一个事件监听器或者启动线程，可以使用一个私有的构造函数和一个公有的工厂方法：在工厂方法中先调用私有构造函数实例化一个变量，然后再发布。

# 线程封闭
  当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭。

  当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。

  1.常用线程封闭方法：
  1)当某个对象封闭在一个线程中时，这种方法将自动实现线程安全性(Swing 与JDBC)。
  
  2)Ad-hoc线程封闭：维护线程封闭性的职责完全由程序实现来承担。
  
  volatile变量存在一种特殊的线程封闭：只要你能确保只有单个线程对共享的volatile变量执行写入操作，那么就可以安全地在这些共享的volatile变量上执行“读取-修改-写入”的操作。相当于修改操作封闭在单个线程中，并且volatile变量的可见性保证还确保了其他线程能看到最新的值。
  
  3)栈封闭
  
  在栈封闭中，只能通过局部变量才能访问对象。(需要防止局部变量(或者该变量的任何内部数据)的引用不被发布出去)

  4)ThreadLocal类
  
  这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get和set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
  
# 不变性
  满足同步需求的另一种方法是使用不可变对象。不可变对象一定是线程安全的。
     
  不可变性并不等于将对象中所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也是可变的，因为在final类型的域中可以保存对可变对象的引用。

  当满足以下条件时，对象才是不可变的：
  
  1)对象创建以后起状态就不能修改。
  2)对象的所有域都是final类型(可以不都是final类型的，例如String，但是不要自己尝试。。。)
  3)对象时正确创建的(在创建过期间，this引用没有逸出)
  
# 安全发布
  任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。这种保证还延伸到被正确创建对象中所有final类型的域。然而，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。

  安全发布的常用模式：
  
  要安全地发布一个对象，对象的引用以及对象的状态必须同时其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

  1)在静态初始化函数中初始化一个对象的引用(JVM内部同步机制保证)
  
  2)将对象的引用保存到volatile类型的域或者AtomicReferace对象中
  
  3)将对象的引用保存到某个正确构造对象的final类型域中
  
  4)将对象的引用保存到一个由锁保护的域中(放到线程安全的容器中)
  
# 事实不可变类
  如果对象从技术上来看是可变的，但其状态在发布后就不会再改变。(例如Date对象)
 
# 对象的发布需求取决于它的可变性：
  1)不可变对象可以通过任意机制来发布
  
  2)事实不可变对象必须通过安全方式来发布
  
  3)可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来

# 安全地共享对象
  当获得一个对象的引用时，你需要知道在这个引用上可以执行那些操作。在使用它之前是否需要获得一个锁？是否可以修改它的状态，或者只能读取它？
     
  在并发程序中使用和共享对象时，可以使用一些使用的策略：
  
  1)线程封闭:线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由整个线程修改。(不共享)
  
  2)只读共享:在没有额外的同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。(只读)
  
  3)线程安全共享:线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。(对象线程安全)

  4)保护对象:被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全的对象中，以及发布的并且有某个特定锁保护的对象。(由特有的锁来保护对象的访问)



